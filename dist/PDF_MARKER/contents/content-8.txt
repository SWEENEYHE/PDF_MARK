《Redis开发与运维》  0
序　言
前　言
致　谢
第1章　初识Redis  1
1.1　盛赞Redis  1
1.2　Redis特性  2
1.3　Redis使用场景  5
1.3.1　Redis可以做什么  5
1.3.2　Redis不可以做什么  5
1.4　用好Redis的建议  6
1.5　正确安装并启动Redis  6
1.5.1　安装Redis  7
1.5.2　配置、启动、操作、关闭Redis  8
1.6　Redis重大版本  11
1.7　本章重点回顾  14
第2章　API的理解和使用  15
2.1　预备  15
2.1.1　全局命令  15
2.1.2　数据结构和内部编码  18
2.1.3　单线程架构  19
2.2　字符串  21
2.2.1　命令  22
2.2.2　内部编码  27
2.2.3　典型使用场景  28
2.3　哈希  31
2.3.1　命令  32
2.3.2　内部编码  35
2.3.3　使用场景  36
2.4　列表  38
2.4.1　命令  38
2.4.2　内部编码  43
2.4.3　使用场景  44
2.5　集合  46
2.5.1　命令  46
2.5.2　内部编码  50
2.5.3　使用场景  51
2.6　有序集合  52
2.6.1　命令  53
2.6.2　内部编码  59
2.6.3　使用场景  59
2.7　键管理  60
2.7.1　单个键管理  60
2.7.2　遍历键  67
2.7.3　数据库管理  70
2.8　本章重点回顾  73
第3章　小功能大用处  74
3.1　慢查询分析  74
3.1.1　慢查询的两个配置参数  75
3.1.2　最佳实践  77
3.2　Redis Shell  78
3.2.1　redis-cli详解  78
3.2.2　redis-server详解  82
3.2.3　redis-benchmark详解  83
3.3　Pipeline  84
3.3.1　Pipeline概念  84
3.3.2　性能测试  85
3.3.3　原生批量命令与Pipeline对比  86
3.3.4　最佳实践  87
3.4　事务与Lua  87
3.4.1　事务  87
3.4.2　Lua用法简述  90
3.4.3　Redis与Lua  92
3.4.4　案例  94
3.4.5　Redis如何管理Lua脚本  96
3.5　Bitmaps  98
3.5.1　数据结构模型  98
3.5.2　命令  98
3.5.3　Bitmaps分析  101
3.6　HyperLogLog  102
3.7　发布订阅  105
3.7.1　命令  106
3.7.2　使用场景  108
3.8　GEO  109
3.9　本章重点回顾  112
第4章　客户端  113
4.1　客户端通信协议  113
4.2　Java客户端Jedis  117
4.2.1　获取Jedis  117
4.2.2　Jedis的基本使用方法  118
4.2.3　Jedis连接池的使用方法  122
4.2.4　Redis中Pipeline的使用方法  125
4.2.5　Jedis的Lua脚本  126
4.3　Python客户端redis-py  128
4.3.1　获取redis-py  128
4.3.2　redis-py的基本使用方法  128
4.3.3　redis-py中Pipeline的使用方法  130
4.3.4　redis-py中的Lua脚本使用方法  130
4.4　客户端管理  131
4.4.1　客户端API  132
4.4.2　客户端相关配置  145
4.4.3　客户端统计片段  145
4.5　客户端常见异常  146
4.6　客户端案例分析  149
4.6.1　Redis内存陡增  149
4.6.2　客户端周期性的超时  151
4.7　本章重点回顾  153
第5章　持久化  154
5.1　RDB  154
5.1.1　触发机制  154
5.1.2　流程说明  155
5.1.3　RDB文件的处理  156
5.1.4　RDB的优缺点  156
5.2　AOF  157
5.2.1　使用AOF  157
5.2.2　命令写入  157
5.2.3　文件同步  158
5.2.4　重写机制  159
5.2.5　重启加载  161
5.2.6　文件校验  162
5.3　问题定位与优化  162
5.3.1　fork操作  162
5.3.2　子进程开销监控和优化  163
5.3.3　AOF追加阻塞  165
5.4　多实例部署  166
5.5　本章重点回顾  167
第6章　复制  168
6.1　配置  168
6.1.1　建立复制  168
6.1.2　断开复制  170
6.1.3　安全性  170
6.1.4　只读  170
6.1.5　传输延迟  171
6.2　拓扑  171
6.3　原理  172
6.3.1　复制过程  172
6.3.2　数据同步  175
6.3.3　全量复制  178
6.3.4　部分复制  181
6.3.5　心跳  183
6.3.6　异步复制  184
6.4　开发与运维中的问题  184
6.4.1　读写分离  184
6.4.2　主从配置不一致  186
6.4.3　规避全量复制  186
6.4.4　规避复制风暴  187
6.5　本章重点回顾  188
第7章　Redis的噩梦：阻塞  189
7.1　发现阻塞  189
7.2　内在原因  191
7.2.1　API或数据结构使用不合理  191
7.2.2　CPU饱和  193
7.2.3　持久化阻塞  194
7.3　外在原因  195
7.3.1　CPU竞争  195
7.3.2　内存交换  195
7.3.3　网络问题  196
7.4　本章重点回顾  199
第8章　理解内存  200
8.1　内存消耗  200
8.1.1　内存使用统计  200
8.1.2　内存消耗划分  201
8.1.3　子进程内存消耗  203
8.2　内存管理  204
8.2.1　设置内存上限  204
8.2.2　动态调整内存上限  204
8.2.3　内存回收策略  205
8.3　内存优化  209
8.3.1　redisObject对象  209
8.3.2　缩减键值对象  210
8.3.3　共享对象池  211
8.3.4　字符串优化  213
8.3.5　编码优化  216
8.3.6　控制键的数量  223
8.4　本章重点回顾  225
第9章　哨兵  226
9.1　基本概念  226
9.1.1　主从复制的问题  227
9.1.2　高可用  227
9.1.3　Redis Sentinel的高可用性  229
9.2　安装和部署  232
9.2.1　部署拓扑结构  232
9.2.2　部署Redis数据节点  233
9.2.3　部署Sentinel节点  234
9.2.4　配置优化  236
9.2.5　部署技巧  243
9.3　API  244
9.4　客户端连接  249
9.4.1　Redis Sentinel的客户端  249
9.4.2　Redis Sentinel客户端基本实现原理  249
9.4.3　Java操作Redis Sentinel  251
9.5　实现原理  254
9.5.1　三个定时监控任务  254
9.5.2　主观下线和客观下线  256
9.5.3　领导者Sentinel节点选举  258
9.5.4　故障转移  261
9.6　开发与运维中的问题  262
9.6.1　故障转移日志分析  262
9.6.2　节点运维  268
9.6.3　高可用读写分离  271
9.7　本章重点回顾  272
第10章　集群  274
10.1　数据分布  274
10.1.1　数据分布理论  274
10.1.2　Redis数据分区  277
10.1.3　集群功能限制  278
10.2　搭建集群  278
10.2.1　准备节点  278
10.2.2　节点握手  280
10.2.3　分配槽  282
10.2.4　用redis-trib.rb搭建集群  284
10.3　节点通信  287
10.3.1　通信流程  287
10.3.2　Gossip消息  287
10.3.3　节点选择  290
10.4　集群伸缩  291
10.4.1　伸缩原理  291
10.4.2　扩容集群  293
10.4.3　收缩集群  301
10.5　请求路由  305
10.5.1　请求重定向  305
10.5.2　Smart客户端  309
10.5.3　ASK重定向  318
10.6　故障转移  323
10.6.1　故障发现  323
10.6.2　故障恢复  329
10.6.3　故障转移时间  334
10.6.4　故障转移演练  334
10.7　集群运维  336
10.7.1　集群完整性  336
10.7.2　带宽消耗  337
10.7.3　Pub/Sub广播问题  337
10.7.4　集群倾斜  338
10.7.5　集群读写分离  339
10.7.6　手动故障转移  341
10.7.7　数据迁移  344
10.8　本章重点回顾  344
第11章　缓存设计  346
11.1　缓存的收益和成本  346
11.2　缓存更新策略  347
11.3　缓存粒度控制  349
11.4　穿透优化  350
11.5　无底洞优化  352
11.6　雪崩优化  359
11.7　热点key重建优化  360
11.8　本章重点回顾  364
第12章　开发运维的“陷阱”  365
12.1　Linux配置优化  365
12.1.1　内存分配控制  365
12.1.2　swappiness  367
12.1.3　THP  369
12.1.4　OOM killer  370
12.1.5　使用NTP  371
12.1.6　ulimit  371
12.1.7　TCP backlog  372
12.2　flushall/flushdb误操作  372
12.2.1　缓存与存储  373
12.2.2　借助AOF机制恢复  373
12.2.3　RDB有什么变化  374
12.2.4　从节点有什么变化  374
12.2.5　快速恢复数据  374
12.3　安全的Redis  375
12.3.1　Redis密码机制  377
12.3.2　伪装危险命令  378
12.3.3　防火墙  380
12.3.4　bind  380
12.3.5　定期备份数据  381
12.3.6　不使用默认端口  381
12.3.7　使用非root用户启动  381
12.4　处理bigkey  382
12.4.1　bigkey的危害  382
12.4.2　如何发现  382
12.4.3　如何删除  383
12.4.4　最佳实践思路  386
12.5　寻找热点key  386
12.6　本章重点回顾  391
第13章　Redis监控运维云平台CacheCloud  392
13.1　CacheCloud是什么  392
13.1.1　现有问题  393
13.1.2　CacheCloud基本功能  393
13.2　快速部署  395
13.2.1　CacheCloud环境需求  395
13.2.2　CacheCloud快速开始  395
13.3　机器部署  397
13.3.1　部署脚本  398
13.3.2　添加机器  399
13.4　接入应用  400
13.4.1　总体流程  401
13.4.2　账户申请和审批  401
13.4.3　应用申请和审批  402
13.4.4　客户端接入  405
13.5　用户功能  407
13.5.1　应用统计信息  408
13.5.2　实例列表  409
13.5.3　应用详情  409
13.5.4　命令曲线  409
13.5.5　CacheCloud Redis Shell控制台  410
13.5.6　慢查询  410
13.5.7　应用拓扑  411
13.6　运维功能  413
13.6.1　应用运维  413
13.6.2　接入已存在的Redis节点  415
13.6.3　Redis配置模板  416
13.6.4　迁移工具  417
13.6.5　监控报警  420
13.6.6　系统配置管理  422
13.7　客户端上报  423
13.7.1　客户端上报整体设计  424
13.7.2　Jedis核心代码修改  424
13.7.3　带上报功能的客户端  426
13.7.4　CacheCloud客户端统计  427
13.8　本章重点回顾  429
第14章　Redis配置统计字典  430
14.1　info系统状态说明  430
14.1.1　命令说明  430
14.1.2　详细说明  431
14.2　standalone配置说明和分析  436
14.2.1　总体配置  436
14.2.2　最大内存及策略  437
14.2.3　AOF相关配置  437
14.2.4　RDB相关配置  438
14.2.5　慢查询配置  438
14.2.6　数据结构优化配置  439
14.2.7　复制相关配置  439
14.2.8　客户端相关配置  440
14.2.9　安全相关配置  440
14.3　Sentinel配置说明和分析  440
14.4　Cluster配置说明和分析  441


